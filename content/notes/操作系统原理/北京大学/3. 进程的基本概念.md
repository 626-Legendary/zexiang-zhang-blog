---
title: 3. 进程与线程模型
date: 2025-12-23
tags: [Operating Systems,学习笔记]
cover: /covers/操作系统原理/北京大学/banner.png
---

# 进程与线程模型（Lecture 3 笔记）

> 本讲重点：**进程概念 · 并发与多道程序设计 · 进程状态与转换 · PCB · 进程控制 · 线程模型与实现**

---

## 一、多道程序设计与并发环境

### 1. 多道程序设计（Multiprogramming）

**定义**：
允许 **多个程序同时进入内存并运行** 的操作系统技术。

**引入目的**：

* 提高 **CPU 利用率**
* 提高 **系统整体吞吐量**

### 2. 逻辑并发的本质

* 物理上：只有 **一个 CPU、一个程序计数器**
* 逻辑上：

  * 每个程序拥有 **独立的逻辑程序计数器**
  * 操作系统通过 **切换** 实现“同时运行”的假象
* 体现了操作系统的 **虚拟性**

📌 **结论**：

* 微观：程序 **轮流** 使用 CPU
* 宏观：程序 **并发执行**

---

## 二、并发环境与进程概念

### 1. 并发环境（Concurrent Environment）

**定义**：
在一段时间区间内：

* 多个程序已经开始运行
* 但都尚未结束
* 执行顺序 **不可预测**

📌 只要执行时间 **有重叠**，即称为并发。

---

### 2. 进程的定义（核心）

> **进程 = 程序在某个数据集合上的一次运行活动**

进程具有双重属性：

* **资源分配单位**
* **CPU 调度单位**

### 3. 进程的关键特性

* 动态性：有生命周期（创建 → 结束）
* 独立性：拥有独立地址空间
* 并发性：可与其他进程并发执行
* 抽象性：是对 CPU 的抽象（虚拟 CPU）

📌 **程序 vs 进程**：

| 程序       | 进程       |
| -------- | -------- |
| 静态       | 动态       |
| 无生命周期    | 有生命周期    |
| 不能并发     | 可以并发     |
| 不能创建其他程序 | 可以创建其他进程 |

---

## 三、进程控制块（PCB）

### 1. PCB 的作用

**PCB（Process Control Block）** 是操作系统：

* **感知进程存在的唯一标志**
* 用于 **管理与控制进程** 的核心数据结构

📌 **一个进程 ⇔ 一个 PCB**

---

### 2. PCB 中的主要信息

#### （1）进程描述信息

* 进程 ID（PID）
* 父进程 / 子进程关系
* 创建用户

#### （2）进程控制信息

* 当前状态
* 优先级
* 程序入口地址
* 各类队列指针

#### （3）资源使用信息

* 地址空间信息
* 打开的文件
* I/O 设备使用情况

#### （4）CPU 现场信息

* 通用寄存器
* PC（程序计数器）
* PSW
* 栈指针
* 页表指针

---

### 3. 进程表

* 所有 PCB 的集合
* 通常大小固定
* 决定系统 **最大并发进程数**

---

## 四、进程状态与状态转换（重点）

### 1. 三种基本状态

| 状态       | 含义            |
| -------- | ------------- |
| 运行态      | 正在 CPU 上执行    |
| 就绪态      | 具备运行条件，等待 CPU |
| 等待态（阻塞态） | 等待事件发生        |

📌 等待态 ≠ 没准备好，而是 **等事件**

---

### 2. 状态转换关系

* 就绪 → 运行：被调度
* 运行 → 就绪：

  * 时间片用完
  * 被高优先级进程抢占
* 运行 → 等待：请求 I/O / 等待事件
* 等待 → 就绪：事件发生

❗ **不存在**：

* 就绪 → 等待
* 等待 → 运行

---

### 3. 扩展状态

* 创建态（New）
* 终止态（Exit）
* 挂起态（Suspend）

📌 挂起态特点：

* 进程被换出内存
* 保存到磁盘
* 用于 **负载调节**

---

### 4. 五状态 / 七状态模型

* 五状态：New / Ready / Running / Blocked / Exit
* 七状态：引入 **就绪挂起 / 阻塞挂起**

---

## 五、进程队列模型

* 就绪队列（可多个）
* 等待队列（按事件分类）
* PCB 在队列间移动即 **状态转换**

📌 状态改变 = PCB 出队 + 入队

---

## 六、进程控制（Process Control）

### 1. 原语（Primitive）

* 不可分割、不可中断的操作
* 通过 **屏蔽中断** 实现

---

### 2. 主要进程控制操作

#### （1）进程创建

* 分配 PID
* 分配 PCB
* 分配地址空间
* 初始化 PCB
* 插入就绪队列

UNIX：`fork + exec`
Windows：`CreateProcess`

---

#### （2）进程终止

* 回收资源
* 关闭文件
* 回收 PCB

UNIX：`exit`
Windows：`TerminateProcess`

---

#### （3）进程阻塞与唤醒

* 阻塞：`wait / sleep`
* 唤醒：事件完成 → 进入就绪态

---

## 七、UNIX 进程机制（fork / exec / wait）

### 1. fork 的基本行为

* 复制父进程
* 子进程返回值 = 0
* 父进程返回值 = 子进程 PID

---

### 2. Linux 的 Copy-On-Write（写时复制）

* fork 时 **不立即复制地址空间**
* 设置为只读共享
* 写操作时才真正复制

📌 **效果**：

* 大幅提升 fork 性能

---

## 八、进程地址空间与进程映像

### 1. 进程地址空间

* 每个进程拥有 **独立的虚拟地址空间**
* 相同虚拟地址 ≠ 相同物理地址

组成：

* 代码段
* 数据段
* 堆
* 栈
* 共享库
* 内存映射文件

---

### 2. 进程映像（Process Image）

> 进程在某一时刻的完整快照

包含：

* 地址空间内容
* 寄存器状态
* PCB
* 内核栈

---

### 3. 上下文切换（Context Switch）

* 保存当前进程寄存器 → PCB
* 恢复新进程寄存器
* CPU 控制权切换

---

## 九、线程的引入（Thread）

### 1. 引入动机

* 应用需求（GUI / Web Server）
* 减少系统开销
* 提高多核性能

---

### 2. 线程的定义

> **线程 = 进程中的一个执行实体**

* CPU 调度单位
* 共享进程资源
* 拥有独立：

  * ID
  * 状态
  * 寄存器
  * 栈

📌 进程：资源拥有者
📌 线程：执行单位

---

## 十、线程实现机制

### 1. 用户级线程（ULT）

**特点**：

* 线程库在用户态
* 内核不知道线程存在
* 切换快

**缺点**：

* 阻塞系统调用会阻塞整个进程
* 无法利用多核

---

### 2. 内核级线程（KLT）

**特点**：

* 内核管理线程
* 线程是调度单位
* 支持多核

📌 代表系统：Windows

---

### 3. 混合模型

* 用户线程映射到内核线程
* 内核负责调度

📌 代表系统：Solaris

---

## 十一、核心总结

* 进程是并发程序执行的抽象
* PCB 是进程存在的唯一标志
* 状态转换 = PCB 在队列间移动

